package action;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import bean.ClinicianBean;
import bean.ClinicianPreferencesBean;
import bean.SessionBean;
import bean.SessionType;
import dao.ClinicianDAO;
import dao.ClinicianPreferencesDAO;
import dao.SessionsDAO;

/**
 * Automates assigning clinicians to each session  
 * 
 * @author lim92, dtli2
 *
 */
public class FillScheduleAction {

	protected Connection conn;

	public FillScheduleAction(Connection connection) {
		conn = connection;
	}

	/**
	 * Assigns clinicians to all sessions generated by GenerateUnfilledScheduleAction
	 */
	public void fillSchedule() {
		try {
			ClinicianDAO clinicianDAO = new ClinicianDAO(this.conn);
			ClinicianPreferencesDAO clinicianPreferencesDAO = new ClinicianPreferencesDAO(this.conn);
			SessionsDAO sessionsDAO = new SessionsDAO(this.conn);
			
			List<ClinicianBean> allClinicians = clinicianDAO.loadClinicians();
			List<SessionBean> sessions = sessionsDAO.loadSessions();

			fillECSchedule(clinicianDAO, clinicianPreferencesDAO, sessionsDAO, allClinicians, sessions);
			fillIASchedule(sessionsDAO, allClinicians, sessions);
		}
		catch(Exception e) { /*System.out.println(e.getClass());System.out.println(e.getMessage());*/ }
	}
	
	/**
	 * Fills the EC schedule.
	 *
	 * @param clinicianDAO the clinician dao
	 * @param clinicianPreferencesDAO the clinician preferences dao
	 * @param sessionsDAO the sessions dao
	 * @param allClinicians the all clinicians
	 * @param sessions the sessions
	 * @throws SQLException the SQL exception
	 */
	private void fillECSchedule(ClinicianDAO clinicianDAO, ClinicianPreferencesDAO clinicianPreferencesDAO,
			SessionsDAO sessionsDAO, List<ClinicianBean> allClinicians, List<SessionBean> sessions) throws SQLException {
		
		HashMap<Integer, Integer> ecAssignments = new HashMap<Integer, Integer>();
		ArrayList<Integer> morningClinicianIDs = new ArrayList<Integer>();
		ArrayList<Integer> noonClinicianIDs = new ArrayList<Integer>();
		ArrayList<Integer> afternoonClinicianIDs = new ArrayList<Integer>();
		int lastDayOfWeek = 5; //Friday is 4
		
		for (SessionBean sb : sessions) {
			if (sb.getType().equals(SessionType.EC)) {
				int currDayOfWeek = sb.getDayOfWeek().ordinal(); 
				
				// for every new week regenerate our 3 arraylists for morning, noon, afternoon clinician ids
				if (currDayOfWeek < lastDayOfWeek) {
					ecAssignments = generateEcAssignments(allClinicians, clinicianDAO, clinicianPreferencesDAO);
					morningClinicianIDs = new ArrayList<Integer>();
					noonClinicianIDs = new ArrayList<Integer>();
					afternoonClinicianIDs = new ArrayList<Integer>();
					for (Integer key : ecAssignments.keySet()) {
						if (ecAssignments.get(key) == 1) {
							morningClinicianIDs.add(key);
						} else if (ecAssignments.get(key) == 2) {
							noonClinicianIDs.add(key);
						} else {
							afternoonClinicianIDs.add(key);
						}
					}
				}
				
				// get new clinician id for session
				List<Integer> clinicianID = new ArrayList<Integer>();
				if (sb.getStartTime() == 8) {
					clinicianID.add(morningClinicianIDs.get(0));
					morningClinicianIDs.remove(0);
				} else if (sb.getStartTime() == 12) {
					clinicianID.add(noonClinicianIDs.get(0));
					noonClinicianIDs.remove(0);
				} else {
					clinicianID.add(afternoonClinicianIDs.get(0));
					afternoonClinicianIDs.remove(0);
				}
				sessionsDAO.insertSessionClinicians(sb.getID(), clinicianID);
				
				lastDayOfWeek = currDayOfWeek;
			}
			
			
		}
	}

	/**
	 * Fills the IA schedule.
	 *
	 * @param sessionsDAO the sessions dao
	 * @param allClinicians the all clinicians
	 * @param sessions the sessions
	 * @throws SQLException the SQL exception
	 */
	private void fillIASchedule(SessionsDAO sessionsDAO, List<ClinicianBean> allClinicians, List<SessionBean> sessions)
			throws SQLException {
		
		// Generating IA schedule
		List<List<Integer>> timeslot1 = new ArrayList<List<Integer>>();
		List<List<Integer>> timeslot2 = new ArrayList<List<Integer>>();
		List<List<Integer>> timeslot3 = new ArrayList<List<Integer>>();
		List<List<Integer>> timeslot4 = new ArrayList<List<Integer>>();
		for (int i = 0; i < 5; i++) {
			Collections.shuffle(allClinicians);
			List<Integer> extendedClinicians = new ArrayList<Integer>();
			int index = 0;
			while (extendedClinicians.size() < 16 && allClinicians.size() > 0) {
				extendedClinicians.add(allClinicians.get(index % allClinicians.size()).getClinicianID());
				index++;
			}
			// First 3 clinicians in list get 11 AM
			timeslot1.add(extendedClinicians.subList(0, 3));
			// Next 5 clinicians get 1 PM (13)
			timeslot2.add(extendedClinicians.subList(3, 8));
			// Next 5 clinicians get 2 PM (14)
			timeslot3.add(extendedClinicians.subList(8, 13));
			// Next 3 clinicians get 3 PM (15)
			timeslot4.add(extendedClinicians.subList(13, 16));
		}
		
		for (SessionBean sb : sessions) {
			if (sb.getType().equals(SessionType.IA)) {
				
				int dayOfWeek = sb.getDayOfWeek().ordinal();
				if (sb.getStartTime() == 11) {
					sessionsDAO.insertSessionClinicians(sb.getID(), timeslot1.get(dayOfWeek));
				} else if (sb.getStartTime() == 13) {
					sessionsDAO.insertSessionClinicians(sb.getID(), timeslot2.get(dayOfWeek));
				} else if (sb.getStartTime() == 14) {
					sessionsDAO.insertSessionClinicians(sb.getID(), timeslot3.get(dayOfWeek));
				} else {
					sessionsDAO.insertSessionClinicians(sb.getID(), timeslot4.get(dayOfWeek));
				}
			}
		}
	}
	
	/**
	 * Calls appropriate assignECSlots method for particular case
	 * @param clinicianDAO
	 * @param clinicianPreferencesDAO
	 * @return
	 * @throws SQLException
	 */
	private HashMap<Integer, Integer> generateEcAssignments(List<ClinicianBean> allClinicians, ClinicianDAO clinicianDAO, ClinicianPreferencesDAO clinicianPreferencesDAO) throws SQLException {
		List<ClinicianPreferencesBean> clinicians = buildPreferencesList(allClinicians, clinicianDAO, clinicianPreferencesDAO);
		HashMap<Integer, Integer> ecAssignments = new HashMap<Integer, Integer>(); // mapping id to assignment
		int[] prefOneCounts = countRankings(clinicians, 1);
		
		// Ideal case with balanced first preferences
		if (prefOneCounts[0] == 5 && prefOneCounts[1] == 5) {
			//System.out.println("1st case");
			ecAssignments = assignECSlotsForE5E5E5(clinicians);
		}

		// Almost-ideal case with only one time slot == 5
		// Fill the 5 count and the <5 count time slots with first
		//// preferences and split the remainder based on second
		//// preferences.
		if ((prefOneCounts[0] == 5 && prefOneCounts[1] != 5) ||
				(prefOneCounts[1] == 5 && prefOneCounts[0] != 5) ||
				(prefOneCounts[2] == 5 && prefOneCounts[0] != 5)) {
			//System.out.println("2nd case");
			ecAssignments = assignECSlotsForLT5E5GT5(clinicians, prefOneCounts);
		}

		// Non-ideal case with one time slot count < 5
		// Fill non-popular choice and then fill the other two
		// Built on the assumption that after completely filling the
		//// unpopular time slot, everyone else can get their first choice.
		if ((prefOneCounts[0] > 5 && prefOneCounts[1] > 5) ||
				(prefOneCounts[0] > 5 && prefOneCounts[2] > 5) ||
				(prefOneCounts[1] > 5 && prefOneCounts[2] > 5)) {
			//System.out.println("Third case");
			ecAssignments = assignECSlotsForLT5GT5GT5(clinicians, prefOneCounts);
			//System.out.println("Third case success");
		}

		// Non-ideal case with two time slot counts < 5
		// Fill non-popular choices and then fill the other one
		// Built on the assumption that all clinicians left to be assigned
		//// after the first round of assignments want the same time slot
		//// for their first choice.
		if ((prefOneCounts[0] < 5 && prefOneCounts[1] < 5) ||
				(prefOneCounts[0] < 5 && prefOneCounts[2] < 5) ||
				(prefOneCounts[1] < 5 && prefOneCounts[2] < 5)) {
			//System.out.println("4th case");
			ecAssignments = assignECSlotsForLT5LT5GT5(clinicians, prefOneCounts);
		}
		
		return ecAssignments;
	}

	/**
	 * Assignment algorithm for case with all counts == 5
	 * @param clinicians
	 * @return ecAssignments
	 */
	private HashMap<Integer, Integer> assignECSlotsForE5E5E5(List<ClinicianPreferencesBean> clinicians) {
		HashMap<Integer, Integer> ecAssignments = new HashMap<Integer, Integer>();
		for (ClinicianPreferencesBean pref : clinicians) {
			ecAssignments.put(pref.getClinicianID(), new Integer(pref.getRanking(1)));
		}
		return ecAssignments;
	}

	/**
	 * Assignment algorithm for case where one count < 5, one count == 5, and one count > 5
	 * @param clinicians
	 * @param prefOneCounts
	 * @return ecAssignments
	 */
	private HashMap<Integer, Integer> assignECSlotsForLT5E5GT5(List<ClinicianPreferencesBean> clinicians, int[] prefOneCounts) {
		//System.out.println("Number of clinicians for assignment: " + clinicians.size());
		HashMap<Integer, Integer> ecAssignments = new HashMap<Integer, Integer>();
		int indexFor5 = -1;
		int indexForLT5 = -1;
		int indexForGT5 = -1;

		if (prefOneCounts[0] == 5) {
			indexFor5 = 0;
		} else if (prefOneCounts[0] > 5) {
			indexForGT5 = 0;
		} else {
			indexForLT5 = 0;
		}

		if (prefOneCounts[1] == 5) {
			indexFor5 = 1;
		} else if (prefOneCounts[1] > 5) {
			indexForGT5 = 1;
		} else {
			indexForLT5 = 1;
		}

		if (prefOneCounts[2] == 5) {
			indexFor5 = 2;
		} else if (prefOneCounts[2] > 5) {
			indexForGT5 = 2;
		} else {
			indexForLT5 = 2;
		}

		int[] assignmentCounts = new int[] {0, 0, 0};

		// Assign clinicians with unpopular preferences to their first choice
		for (int i = 14; i >= 0; i--) {
			if (clinicians.get(i).getRanking(1) == indexFor5 + 1 ||
					clinicians.get(i).getRanking(1) == indexForLT5 + 1) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(clinicians.get(i).getRanking(1)));
				assignmentCounts[clinicians.get(i).getRanking(1) - 1]++;
				clinicians.remove(i);
			}
		}

		// First try to assign remaining indexForLT5 slots based on prefTwo
		Collections.shuffle(clinicians);
		for (int i = clinicians.size() - 1; i >= 0; i--) {
			if (clinicians.get(i).getRanking(2) == indexForLT5 + 1 && 
					assignmentCounts[indexForLT5] < 5) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(clinicians.get(i).getRanking(2)));
				assignmentCounts[clinicians.get(i).getRanking(2) - 1]++;
				clinicians.remove(i);
			}
		}

		//System.out.println("Num clinicians left to assign: " + clinicians.size());
		//System.out.println("Num clinicians already assigned: " + ecAssignments.keySet().size());
		//System.out.println("Assignment counts: " + assignmentCounts[0] + " " + assignmentCounts[1] + " " + assignmentCounts[2]);
		// In case we still aren't done, assign the rest randomly
		if (clinicians.size() > 0) {
			Collections.shuffle(clinicians);
			// Assign the remaining indexForLT5 slots
			int numNeededForLT5 = 5 - assignmentCounts[indexForLT5];
			for (int i = 0; i < numNeededForLT5; i++) {
				ecAssignments.put(new Integer(clinicians.get(0).getClinicianID()), new Integer(indexForLT5 + 1));
				assignmentCounts[indexForLT5]++;
				clinicians.remove(0);
				//System.out.println("Assignment counts: " + assignmentCounts[0] + " " + assignmentCounts[1] + " " + assignmentCounts[2]);
			}
			// Assign the remaining slots
			for (int i = 0; i < 5; i++) {
				ecAssignments.put(new Integer(clinicians.get(0).getClinicianID()), new Integer(indexForGT5 + 1));
				assignmentCounts[indexForGT5]++;
				clinicians.remove(0);
				//System.out.println("Assignment counts: " + assignmentCounts[0] + " " + assignmentCounts[1] + " " + assignmentCounts[2]);
			}
		}
		//System.out.println("Num clinicians remaining should be 0: " + clinicians.size());

		return ecAssignments;
	}

	/**
	 * Assignment algorithm for case where one count < 5 and two counts > 5
	 * @param clinicians
	 * @param prefOneCounts
	 * @return ecAssignments
	 */
	private HashMap<Integer, Integer> assignECSlotsForLT5GT5GT5(List<ClinicianPreferencesBean> clinicians, int[] prefOneCounts) {
		HashMap<Integer, Integer> ecAssignments = new HashMap<Integer, Integer>();

		int indexForLT5 = -1;
		int indexForGT5a = -1;
		int indexForGT5b = -1;

		if (prefOneCounts[0] < 5) {
			indexForLT5 = 0;
			indexForGT5a = 1;
			indexForGT5b = 2;
		} else if (prefOneCounts[1] < 5) {
			indexForLT5 = 1;
			indexForGT5a = 0;
			indexForGT5b = 2;
		} else {
			indexForLT5 = 2;
			indexForGT5a = 0;
			indexForGT5b = 1;
		}

		// Assign clinicians with least popular time slot as first choice
		for (int i = 14; i >= 0; i--) {
			if (clinicians.get(i).getRanking(1) - 1 == indexForLT5) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5 + 1));
				clinicians.remove(i);
			}
		}

		Collections.shuffle(clinicians);

		// Assign clinicians with first pref = GT5a to LT5 based on second pref
		int excessGT5a = prefOneCounts[indexForGT5a] - 5;
		int countExcessAssignedGT5a = 0;
		for (int i = clinicians.size() - 1; i >= 0; i--) {
			if (clinicians.get(i).getRanking(1) - 1 == indexForGT5a && clinicians.get(i).getRanking(2) - 1 == indexForLT5) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5 + 1));
				clinicians.remove(i);
				countExcessAssignedGT5a++;
			}
			if (excessGT5a == countExcessAssignedGT5a) {
				break;
			}
		}

		// Assign clinicians with first pref = GT5b to LT5 based on second pref
		int excessGT5b = prefOneCounts[indexForGT5b] - 5;
		int countExcessAssignedGT5b = 0;
		for (int i = clinicians.size() - 1; i >= 0; i--) {
			if (clinicians.get(i).getRanking(1) - 1 == indexForGT5b && clinicians.get(i).getRanking(2) - 1 == indexForLT5) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5 + 1));
				clinicians.remove(i);
				countExcessAssignedGT5b++;
			}
			if (excessGT5b == countExcessAssignedGT5b) {
				break;
			}
		}

		// Assign excess clinicians with first pref = GT5a randomly
		if (excessGT5a > countExcessAssignedGT5a) {
			for (int i = clinicians.size() - 1; i >= 0; i--) {
				if (excessGT5a > countExcessAssignedGT5a) {
					if (clinicians.get(i).getRanking(1) - 1 == indexForGT5a) {
						ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5 + 1));
						clinicians.remove(i);
						countExcessAssignedGT5a++;
					}
				} else {
					break;
				}
			}
		}

		// Assign excess clinicians with first pref = GT5b randomly
		if (excessGT5b > countExcessAssignedGT5b) {
			for (int i = clinicians.size() - 1; i >= 0; i--) {
				if (excessGT5b > countExcessAssignedGT5b) {
					if (clinicians.get(i).getRanking(1) - 1 == indexForGT5b) {
						ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5 + 1));
						clinicians.remove(i);
						countExcessAssignedGT5b++;
					}
				} else {
					break;
				}
			}
		}

		// Assign remaining clinicians to their first pref
		for (ClinicianPreferencesBean pref : clinicians) {
			ecAssignments.put(new Integer(pref.getClinicianID()), new Integer(pref.getRanking(1)));
		}
		
		//System.out.println("Created ecAssignments with this number of keys: " + ecAssignments.keySet().size());

		return ecAssignments;
	}

	/**
	 * Assignment algorithm for case where two counts < 5 and one count > 5
	 * @param clinicians
	 * @param prefOneCounts
	 * @return ecAssignments
	 */
	private HashMap<Integer, Integer> assignECSlotsForLT5LT5GT5(List<ClinicianPreferencesBean> clinicians, int[] prefOneCounts) {
		HashMap<Integer, Integer> ecAssignments = new HashMap<Integer, Integer>();

		int indexForLT5a = -1;
		int indexForLT5b = -1;
		int indexForGT5 = -1;

		if (prefOneCounts[0] > 5) {
			indexForGT5 = 0;
			indexForLT5a = 1;
			indexForLT5b = 2;
		} else if (prefOneCounts[1] > 5) {
			indexForGT5 = 1;
			indexForLT5a = 0;
			indexForLT5b = 2;
		} else {
			indexForGT5 = 2;
			indexForLT5a = 0;
			indexForLT5b = 1;
		}
		
		//System.out.println("1");

		// Assign clinicians with first pref < 5
		for (int i = 14; i >= 0; i--) {
			if (clinicians.get(i).getRanking(1) - 1 == indexForLT5a ||
					clinicians.get(i).getRanking(1) - 1 == indexForLT5b) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(clinicians.get(i).getRanking(1)));
				clinicians.remove(i);
			}
		}
		
		//System.out.println("2");

		Collections.shuffle(clinicians);

		// Try to assign GT5 clinicians to second pref
		int excessLT5a = 5 - prefOneCounts[indexForLT5a];
		int excessLT5b = 5 - prefOneCounts[indexForLT5b];
		int countExcessAssignedLT5a = 0;
		int countExcessAssignedLT5b = 0;
		for (int i = clinicians.size() - 1; i >= 0; i--) {
			if (clinicians.get(i).getRanking(2) - 1 == indexForLT5a && countExcessAssignedLT5a < excessLT5a) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5a + 1));
				clinicians.remove(i);
				countExcessAssignedLT5a++;
			} else if (clinicians.get(i).getRanking(2) - 1 == indexForLT5b && countExcessAssignedLT5b < excessLT5b) {
				ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(indexForLT5b + 1));
				clinicians.remove(i);
				countExcessAssignedLT5b++;
			}
		}
		
		//System.out.println("3");

		Collections.shuffle(clinicians);

		// Assign LT5a randomly
		if (countExcessAssignedLT5a < excessLT5a) {
			for (int i = 0; i < excessLT5a - countExcessAssignedLT5a; i++) {
				ecAssignments.put(new Integer(clinicians.get(0).getClinicianID()), new Integer(indexForLT5a + 1));
				clinicians.remove(0);
			}
		}

		// Assign LT5b randomly
		if (countExcessAssignedLT5b < excessLT5b) {
			for (int i = 0; i < excessLT5b - countExcessAssignedLT5b; i++) {
				ecAssignments.put(new Integer(clinicians.get(0).getClinicianID()), new Integer(indexForLT5b + 1));
				clinicians.remove(0);
			}
		}
		//System.out.println("4");

		// Assign the rest to pref one
		for (int i = 0; i < 5; i++) {
			ecAssignments.put(new Integer(clinicians.get(i).getClinicianID()), new Integer(clinicians.get(i).getRanking(1)));
		}

		return ecAssignments;
	}

	/**
	 * Helper method to count the number of clinicians who want each time slot, for their first preference or second preference
	 * @param clinicianPrefs
	 * @param rank
	 * @return
	 */
	private int[] countRankings(List<ClinicianPreferencesBean> clinicianPrefs, int rank) {
		int[] counts = new int[] {0 , 0 , 0};

		for(ClinicianPreferencesBean pref : clinicianPrefs) {
			if (rank == 1) {
				////System.out.println("pref one: " + pref.id + " " + pref.getRanking(1));
				counts[pref.getRanking(1) - 1]++;
			}
			if (rank == 2) {
				counts[pref.getRanking(2) - 1]++;
			}
		}

		return counts;
	}

	/**
	 * Given the list of all clinicians in the system, return a list of 15 random clinicians associated with their first and second
	 * choice time slots. If there are less than 15 clinicians in the system, duplicate allClinicians and randomly select clinicians to
	 * fill any left over spots, to make the list length 15.
	 * @param allClinicians
	 * @param clincianDAO
	 * @param clinicianPreferencesDAO
	 * @return
	 * @throws SQLException
	 */
	private List<ClinicianPreferencesBean> buildPreferencesList(List<ClinicianBean> allClinicians, ClinicianDAO clincianDAO, ClinicianPreferencesDAO clinicianPreferencesDAO) throws SQLException {
		List<ClinicianPreferencesBean> clinicians = new ArrayList<>();

		Collections.shuffle(allClinicians);

		if(allClinicians.size() >= 15) {
			List<ClinicianBean> beans = new ArrayList<ClinicianBean> (allClinicians.subList(0, 15));
			for (ClinicianBean bean : beans) {
				clinicians.add(clinicianPreferencesDAO.loadClinicianPreferences(bean.getClinicianID()));
			}
		}
		else {
			List<ClinicianBean> beans = new ArrayList<ClinicianBean> (allClinicians.subList(0, (int) (15 - allClinicians.size() * Math.floor(15.0 / allClinicians.size()))));
			for (ClinicianBean bean : beans) {
				clinicians.add(clinicianPreferencesDAO.loadClinicianPreferences(bean.getClinicianID()));
			}
			for (int c = 0; c < allClinicians.size(); c++) {
				for (int i = 0; i < Math.floor(15.0 / allClinicians.size()); i++) {
					ClinicianBean cb = allClinicians.get(c);
					clinicians.add(clinicianPreferencesDAO.loadClinicianPreferences(cb.getClinicianID()));
				}
			}
		}
		return clinicians;		
	}
}